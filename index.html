<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cờ Vua AI V3 - Fix Màu Quân</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #221510; color: #e0d4c6;
            display: flex; justify-content: center; align-items: center;
            min-height: 100vh; padding: 10px;
        }
        .container { 
            display: flex; flex-direction: column; align-items: center; gap: 15px; 
            width: 100%; max-width: 800px;
        }
        .title h1 { 
            font-size: 2rem; color: #c5a083; text-transform: uppercase; 
            text-align: center; margin-bottom: 5px; 
        }
        
        /* --- HEADER --- */
        .game-header { display: flex; flex-direction: column; gap: 10px; width: 100%; }
        .game-info-bar {
            display: flex; justify-content: space-between; align-items: center;
            background: #36231a; border: 1px solid #5a3e2b; padding: 10px 15px; border-radius: 4px;
        }
        .turn-display { font-size: 1rem; font-weight: 600; }
        .timer-box {
            background-color: #221510; padding: 5px 12px; border-radius: 4px;
            border: 1px solid #5a3e2b; font-family: 'Consolas', monospace;
            font-size: 1.2rem; font-weight: bold; color: #fff;
        }
        .timer-box.warning { color: #e74c3c; animation: pulse 1s infinite; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
        .new-game-btn {
            padding: 6px 12px; background: #5a3e2b; color: #e0d4c6;
            border: 1px solid #75523b; cursor: pointer; font-weight: bold; font-size: 0.9rem;
        }
        .new-game-btn:hover { background: #75523b; }

        /* --- GAME CONTAINER --- */
        .game-main {
            display: flex; gap: 20px; background: #2b1b15;
            padding: 20px; border: 1px solid #4a3225;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            justify-content: center;
        }

        /* --- BÀN CỜ --- */
        .chess-board {
            display: grid; 
            grid-template-columns: repeat(8, 70px); 
            grid-template-rows: repeat(8, 70px);
            border: 8px solid #5a3e2b; user-select: none;
            background: #5a3e2b;
        }
        .chess-square {
            width: 70px; height: 70px; display: flex; align-items: center; justify-content: center;
            font-size: 52px; position: relative; cursor: pointer;
        }
        .chess-square.light { background-color: #e8cba5; }
        .chess-square.dark { background-color: #ae7446; }
        
        /* --- MÀU SẮC QUÂN CỜ (SỬA LỖI TẠI ĐÂY) --- */
        .piece { 
            pointer-events: none; 
            z-index: 2; 
            line-height: 1; 
            font-family: "Segoe UI Symbol", "Arial Unicode MS", sans-serif; 
            font-weight: bold;
        }
        
        /* Quân TRẮNG: Màu trắng, viền đen nhẹ */
        .piece.white {
            color: #ffffff !important;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            filter: drop-shadow(0 2px 1px rgba(0,0,0,0.5));
        }
        
        /* Quân ĐEN: Màu đen tuyền, viền trắng phát sáng để nổi trên nền gỗ */
        .piece.black {
            color: #000000 !important;
            text-shadow: 0px 0px 2px #ffffff, 0px 0px 4px #ffffff; /* Viền sáng bao quanh */
        }

        .chess-square.selected { background-color: #f5e364 !important; }
        .chess-square.dark.selected { background-color: #d4b648 !important; }
        .chess-square.valid-move::before {
            content: ''; position: absolute; width: 25%; height: 25%;
            background-color: rgba(0, 0, 0, 0.2); border-radius: 50%;
        }
        .chess-square.valid-move.has-piece { box-shadow: inset 0 0 0 4px rgba(200, 0, 0, 0.4); }
        .chess-square.valid-move.has-piece::before { display: none; }

        /* --- LỊCH SỬ & MODAL --- */
        .move-history {
            width: 200px; height: 576px; background: #36231a; border: 1px solid #5a3e2b;
            display: flex; flex-direction: column;
        }
        .history-header { background: #4a3225; padding: 10px; text-align: center; font-weight: bold; border-bottom: 1px solid #5a3e2b; }
        .move-list { flex: 1; overflow-y: auto; padding: 10px; font-family: monospace; font-size: 0.9rem; }
        .move-row { display: flex; justify-content: space-between; margin-bottom: 5px; border-bottom: 1px solid #443025; }
        
        .promotion-modal {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.8);
            z-index: 1000; display: none; justify-content: center; align-items: center;
        }
        .promotion-modal.show { display: flex; }
        .promotion-options { display: flex; gap: 15px; background: #36231a; padding: 20px; border: 2px solid #c5a083; }
        .promotion-btn { font-size: 40px; cursor: pointer; background: none; border: none; transition: transform 0.2s; }

        /* --- MOBILE --- */
        @media (max-width: 850px) {
            .game-main { flex-direction: column; align-items: center; padding: 10px; width: 100%; }
            .chess-board {
                grid-template-columns: repeat(8, 11.5vw);
                grid-template-rows: repeat(8, 11.5vw);
            }
            .chess-square { width: 11.5vw; height: 11.5vw; font-size: 8.5vw; }
            .move-history { width: 100%; height: 120px; max-width: 92vw; }
            .title h1 { font-size: 1.5rem; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="title"><h1>Cờ Vua (V3)</h1></div>
        <div class="game-header">
            <div class="game-info-bar">
                <div class="turn-display" id="turnInfo">Lượt: Trắng</div>
                <div class="timer-box" id="timerDisplay">60</div>
                <button class="new-game-btn" onclick="resetGame()">Ván Mới</button>
            </div>
        </div>
        <div class="game-main">
            <div class="chess-board" id="chessBoard"></div>
            <div class="move-history">
                <div class="history-header">Biên Bản</div>
                <div class="move-list" id="moveList"></div>
            </div>
        </div>
    </div>
    <div class="promotion-modal" id="promotionModal">
        <div class="promotion-options" id="promotionOptions"></div>
    </div>

    <script>
        // --- KHAI BÁO QUÂN CỜ (DÙNG CHUNG KÝ TỰ ĐẶC CHO CẢ 2 BÊN ĐỂ DỄ TÔ MÀU) ---
        const PIECE_CHARS = {
            'king': '♚', 'queen': '♛', 'rook': '♜', 'bishop': '♝', 'knight': '♞', 'pawn': '♟'
        };
        
        const MOVE_TIME_LIMIT = 60;
        const PIECE_VALUES = { p: 100, n: 320, b: 330, r: 500, q: 900, k: 20000 };
        
        // PST (Bảng điểm vị trí)
        const PST = {
            pawn: [ [0,0,0,0,0,0,0,0], [50,50,50,50,50,50,50,50], [10,10,20,30,30,20,10,10], [5,5,10,25,25,10,5,5], [0,0,0,20,20,0,0,0], [5,-5,-10,0,0,-10,-5,5], [5,10,10,-20,-20,10,10,5], [0,0,0,0,0,0,0,0] ],
            knight: [ [-50,-40,-30,-30,-30,-30,-40,-50], [-40,-20,0,0,0,0,-20,-40], [-30,0,10,15,15,10,0,-30], [-30,5,15,20,20,15,5,-30], [-30,0,15,20,20,15,0,-30], [-30,5,10,15,15,10,5,-30], [-40,-20,0,5,5,0,-20,-40], [-50,-40,-30,-30,-30,-30,-40,-50] ],
            bishop: [ [-20,-10,-10,-10,-10,-10,-10,-20], [-10,0,0,0,0,0,0,-10], [-10,0,5,10,10,5,0,-10], [-10,5,5,10,10,5,5,-10], [-10,0,10,10,10,10,0,-10], [-10,10,10,10,10,10,10,-10], [-10,5,0,0,0,0,5,-10], [-20,-10,-10,-10,-10,-10,-10,-20] ],
            rook: [ [0,0,0,0,0,0,0,0], [5,10,10,10,10,10,10,5], [-5,0,0,0,0,0,0,-5], [-5,0,0,0,0,0,0,-5], [-5,0,0,0,0,0,0,-5], [-5,0,0,0,0,0,0,-5], [-5,0,0,0,0,0,0,-5], [0,0,0,5,5,0,0,0] ],
            queen: [ [-20,-10,-10,-5,-5,-10,-10,-20], [-10,0,0,0,0,0,0,-10], [-10,0,5,5,5,5,0,-10], [-5,0,5,5,5,5,0,-5], [0,0,5,5,5,5,0,-5], [-10,5,5,5,5,5,0,-10], [-10,0,5,0,0,0,0,-10], [-20,-10,-10,-5,-5,-10,-10,-20] ],
            king: [ [-30,-40,-40,-50,-50,-40,-40,-30], [-30,-40,-40,-50,-50,-40,-40,-30], [-30,-40,-40,-50,-50,-40,-40,-30], [-30,-40,-40,-50,-50,-40,-40,-30], [-20,-30,-30,-40,-40,-30,-30,-20], [-10,-20,-20,-20,-20,-20,-20,-10], [20,20,0,0,0,0,20,20], [20,30,10,0,0,10,30,20] ]
        };

        let gameState = {
            board: [], currentTurn: 'white', selectedPiece: null, validMoves: [],
            isCheck: false, isGameOver: false, enPassantTarget: null,
            isAIThinking: false, promotionPosition: null, moveHistory: [],
            timeRemaining: MOVE_TIME_LIMIT, timerInterval: null
        };

        function initializeBoard() {
            const board = Array(8).fill(null).map(() => Array(8).fill(null));
            const blackOrder = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];
            blackOrder.forEach((type, col) => board[0][col] = { type, color: 'black', hasMoved: false });
            for (let i = 0; i < 8; i++) board[1][i] = { type: 'pawn', color: 'black', hasMoved: false };
            const whiteOrder = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];
            whiteOrder.forEach((type, col) => board[7][col] = { type, color: 'white', hasMoved: false });
            for (let i = 0; i < 8; i++) board[6][i] = { type: 'pawn', color: 'white', hasMoved: false };
            return board;
        }

        // --- TIMER & UI ---
        function startTimer() {
            clearInterval(gameState.timerInterval);
            gameState.timeRemaining = MOVE_TIME_LIMIT;
            updateTimerUI();
            gameState.timerInterval = setInterval(() => {
                gameState.timeRemaining--;
                updateTimerUI();
                if (gameState.timeRemaining <= 0) {
                    clearInterval(gameState.timerInterval);
                    endGameTimeout();
                }
            }, 1000);
        }
        function updateTimerUI() {
            const display = document.getElementById('timerDisplay');
            display.textContent = gameState.timeRemaining;
            if (gameState.timeRemaining <= 10) display.classList.add('warning');
            else display.classList.remove('warning');
        }
        function endGameTimeout() {
            gameState.isGameOver = true;
            const winner = gameState.currentTurn === 'white' ? 'Đen' : 'Trắng';
            alert(`HẾT GIỜ! ${winner} chiến thắng.`);
            document.getElementById('turnInfo').innerHTML = `<span style="color:red">Hết giờ - ${winner} thắng</span>`;
        }
        function stopTimer() { clearInterval(gameState.timerInterval); }

        // --- LOGIC ---
        function getPieceAt(board, row, col) {
            if (row < 0 || row > 7 || col < 0 || col > 7) return null;
            return board[row][col];
        }

        function getValidMoves(board, piece, pos, checkSafety = true) {
            let moves = [];
            const { row, col } = pos;
            if (piece.type === 'pawn') {
                const dir = piece.color === 'white' ? -1 : 1;
                const startRow = piece.color === 'white' ? 6 : 1;
                if (!getPieceAt(board, row + dir, col)) {
                    moves.push({ row: row + dir, col });
                    if (row === startRow && !getPieceAt(board, row + dir * 2, col)) moves.push({ row: row + dir * 2, col });
                }
                [-1, 1].forEach(dc => {
                    const t = getPieceAt(board, row + dir, col + dc);
                    if (t && t.color !== piece.color) moves.push({ row: row + dir, col: col + dc });
                    if (gameState.enPassantTarget && gameState.enPassantTarget.row === row + dir && gameState.enPassantTarget.col === col + dc) {
                        moves.push({ row: row + dir, col: col + dc });
                    }
                });
            } else if (piece.type === 'knight' || piece.type === 'king') {
                const deltas = piece.type === 'knight' 
                    ? [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]]
                    : [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
                deltas.forEach(([dr, dc]) => {
                    const r = row + dr, c = col + dc;
                    const t = getPieceAt(board, r, c);
                    if (r >= 0 && r < 8 && c >= 0 && c < 8 && (!t || t.color !== piece.color)) moves.push({ row: r, col: c });
                });
                if (piece.type === 'king' && !piece.hasMoved && checkSafety && !isInCheck(board, piece.color)) {
                    if (!getPieceAt(board, row, 5) && !getPieceAt(board, row, 6)) {
                        const r = getPieceAt(board, row, 7);
                        if (r && !r.hasMoved) moves.push({row, col: 6});
                    }
                    if (!getPieceAt(board, row, 1) && !getPieceAt(board, row, 2) && !getPieceAt(board, row, 3)) {
                        const r = getPieceAt(board, row, 0);
                        if (r && !r.hasMoved) moves.push({row, col: 2});
                    }
                }
            } else {
                const dirs = piece.type === 'bishop' ? [[-1,-1],[-1,1],[1,-1],[1,1]] :
                             piece.type === 'rook' ? [[-1,0],[1,0],[0,-1],[0,1]] :
                             [[-1,-1],[-1,1],[1,-1],[1,1],[-1,0],[1,0],[0,-1],[0,1]];
                dirs.forEach(([dr, dc]) => {
                    let r = row + dr, c = col + dc;
                    while (r >= 0 && r < 8 && c >= 0 && c < 8) {
                        const t = getPieceAt(board, r, c);
                        if (!t) moves.push({ row: r, col: c });
                        else {
                            if (t.color !== piece.color) moves.push({ row: r, col: c });
                            break;
                        }
                        r += dr; c += dc;
                    }
                });
            }
            if (checkSafety) return moves.filter(m => !wouldBeInCheck(board, pos, m, piece.color));
            return moves;
        }

        function wouldBeInCheck(board, from, to, color) {
            const tempBoard = board.map(row => row.map(p => p ? {...p} : null));
            const p = tempBoard[from.row][from.col];
            tempBoard[to.row][to.col] = p;
            tempBoard[from.row][from.col] = null;
            return isInCheck(tempBoard, color);
        }

        function isInCheck(board, color) {
            let kPos = null;
            for(let r=0; r<8; r++) for(let c=0; c<8; c++) {
                if(board[r][c] && board[r][c].type === 'king' && board[r][c].color === color) kPos = {r, c};
            }
            if (!kPos) return false;
            const enemy = color === 'white' ? 'black' : 'white';
            for(let r=0; r<8; r++) for(let c=0; c<8; c++) {
                const p = board[r][c];
                if (p && p.color === enemy) {
                    const moves = getValidMoves(board, p, {row:r,col:c}, false);
                    if (moves.some(m => m.row === kPos.r && m.col === kPos.c)) return true;
                }
            }
            return false;
        }

        function makeMove(from, to) {
            const piece = gameState.board[from.row][from.col];
            const isCapture = gameState.board[to.row][to.col] !== null;
            
            if (piece.type === 'pawn' && gameState.enPassantTarget && to.row === gameState.enPassantTarget.row && to.col === gameState.enPassantTarget.col) {
                gameState.board[from.row][to.col] = null;
            }
            if (piece.type === 'king' && Math.abs(to.col - from.col) === 2) {
                const rookCol = to.col > from.col ? 7 : 0;
                const newRookCol = to.col > from.col ? 5 : 3;
                const rook = gameState.board[from.row][rookCol];
                gameState.board[from.row][newRookCol] = { ...rook, hasMoved: true };
                gameState.board[from.row][rookCol] = null;
            }

            gameState.board[to.row][to.col] = { ...piece, hasMoved: true };
            gameState.board[from.row][from.col] = null;
            
            if (piece.type === 'pawn' && (to.row === 0 || to.row === 7)) {
                if (piece.color === 'black') {
                    gameState.board[to.row][to.col].type = 'queen';
                    finalizeMove(piece, to, isCapture);
                } else {
                    gameState.promotionPosition = to;
                    stopTimer();
                    showPromotionModal(piece.color);
                }
                return;
            }
            gameState.enPassantTarget = (piece.type === 'pawn' && Math.abs(to.row - from.row) === 2) 
                ? { row: (from.row + to.row) / 2, col: to.col } : null;
            finalizeMove(piece, to, isCapture);
        }

        function finalizeMove(piece, to, isCapture) {
            const cols = 'abcdefgh';
            const notation = (piece.type === 'pawn' ? '' : (piece.type==='knight'?'N':piece.type[0].toUpperCase())) + 
                             (isCapture?'x':'') + cols[to.col] + (8-to.row);
            gameState.moveHistory.push(notation);
            endTurn();
        }

        function endTurn() {
            gameState.currentTurn = gameState.currentTurn === 'white' ? 'black' : 'white';
            gameState.selectedPiece = null;
            gameState.validMoves = [];
            if (!gameState.isGameOver) startTimer();

            const isCheck = isInCheck(gameState.board, gameState.currentTurn);
            let hasMove = false;
            for(let r=0; r<8; r++) for(let c=0; c<8; c++) {
                if (gameState.board[r][c] && gameState.board[r][c].color === gameState.currentTurn) {
                    if (getValidMoves(gameState.board, gameState.board[r][c], {row:r, col:c}).length > 0) hasMove = true;
                }
            }

            if (!hasMove) {
                stopTimer();
                gameState.isGameOver = true;
                if (isCheck) alert(`CHIẾU BÍ! ${gameState.currentTurn === 'white' ? 'Đen' : 'Trắng'} thắng.`);
                else alert("HÒA CỜ!");
            }

            renderBoard();
            updateTurnDisplay();

            if (gameState.currentTurn === 'black' && !gameState.isGameOver) {
                gameState.isAIThinking = true;
                setTimeout(() => {
                    makeBestMove();
                    gameState.isAIThinking = false;
                }, 100);
            }
        }

        // --- AI V2 (MINIMAX + ALPHA BETA) ---
        function makeBestMove() {
            const depth = 4; 
            const bestMove = minimaxRoot(depth, gameState.board, true);
            if (bestMove) {
                makeMove(bestMove.from, bestMove.to);
            }
        }

        function getVal(piece) {
            if (!piece) return 0;
            return PIECE_VALUES[piece.type === 'knight' ? 'n' : piece.type[0]];
        }

        function getPSTValue(piece, r, c) {
            const tbl = PST[piece.type];
            if (!tbl) return 0;
            return tbl[piece.color === 'white' ? r : 7 - r][c];
        }

        function kingSafety(board) {
            let score = 0;
            const dirs = [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[-1,1],[1,-1],[1,1]];
            for(let r=0; r<8; r++) {
                for(let c=0; c<8; c++) {
                    const p = board[r][c];
                    if (p && p.type === 'king') {
                        let safe = 0;
                        dirs.forEach(d => {
                            const nr = r + d[0], nc = c + d[1];
                            if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                                const q = board[nr][nc];
                                if (q && q.color === p.color) safe += 5;
                            }
                        });
                        score += p.color === 'white' ? safe : -safe;
                    }
                }
            }
            return score;
        }

        function evaluateBoard(board) {
            let score = 0;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const p = board[r][c];
                    if (!p) continue;
                    let base = getVal(p);
                    let pst = getPSTValue(p, r, c);
                    score += (p.color === 'white' ? base + pst : -base - pst);
                }
            }
            score += kingSafety(board);
            return score;
        }

        function minimaxRoot(depth, board, isMaximizing) {
            const newGameMoves = getAllMoves(board, 'black');
            let bestMove = -Infinity;
            let bestMoveFound;

            newGameMoves.sort((a, b) => {
                const captureA = board[a.to.row][a.to.col];
                const captureB = board[b.to.row][b.to.col];
                const pieceA = board[a.from.row][a.from.col];
                const pieceB = board[b.from.row][b.from.col];
                const scoreA = (captureA ? getVal(captureA) : 0) - getVal(pieceA) * 0.1;
                const scoreB = (captureB ? getVal(captureB) : 0) - getVal(pieceB) * 0.1;
                return scoreB - scoreA;
            });

            for(let i = 0; i < newGameMoves.length; i++) {
                const move = newGameMoves[i];
                const newBoard = simulateMove(board, move);
                const value = minimax(depth - 1, newBoard, -Infinity, Infinity, !isMaximizing);
                if(value >= bestMove) {
                    bestMove = value;
                    bestMoveFound = move;
                }
            }
            return bestMoveFound;
        }

        function minimax(depth, board, alpha, beta, isMaximizing) {
            if (depth === 0) return -evaluateBoard(board);

            const moves = getAllMoves(board, isMaximizing ? 'black' : 'white');
            if (moves.length === 0) return isMaximizing ? -20000 : 20000;

            if (isMaximizing) {
                let bestMove = -Infinity;
                for (let i = 0; i < moves.length; i++) {
                    const newBoard = simulateMove(board, moves[i]);
                    bestMove = Math.max(bestMove, minimax(depth - 1, newBoard, alpha, beta, !isMaximizing));
                    alpha = Math.max(alpha, bestMove);
                    if (beta <= alpha) return bestMove;
                }
                return bestMove;
            } else {
                let bestMove = Infinity;
                for (let i = 0; i < moves.length; i++) {
                    const newBoard = simulateMove(board, moves[i]);
                    bestMove = Math.min(bestMove, minimax(depth - 1, newBoard, alpha, beta, !isMaximizing));
                    beta = Math.min(beta, bestMove);
                    if (beta <= alpha) return bestMove;
                }
                return bestMove;
            }
        }

        function getAllMoves(board, color) {
            let moves = [];
            for(let r=0; r<8; r++) for(let c=0; c<8; c++) {
                const p = board[r][c];
                if(p && p.color === color) {
                    const vMoves = getValidMoves(board, p, {row:r, col:c});
                    vMoves.forEach(to => moves.push({from: {row:r, col:c}, to}));
                }
            }
            return moves;
        }

        function simulateMove(board, move) {
            const newBoard = board.map(row => row.map(p => p ? {...p} : null));
            const p = newBoard[move.from.row][move.from.col];
            newBoard[move.to.row][move.to.col] = p;
            newBoard[move.from.row][move.from.col] = null;
            return newBoard;
        }

        // --- RENDER ---
        function renderBoard() {
            const el = document.getElementById('chessBoard');
            el.innerHTML = '';
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const sq = document.createElement('div');
                    sq.className = `chess-square ${(r + c) % 2 === 0 ? 'light' : 'dark'}`;
                    const piece = gameState.board[r][c];
                    if (piece) {
                        const p = document.createElement('div');
                        p.className = `piece ${piece.color}`;
                        p.textContent = PIECE_CHARS[piece.type];
                        sq.appendChild(p);
                    }
                    if (gameState.selectedPiece && gameState.selectedPiece.row === r && gameState.selectedPiece.col === c) sq.classList.add('selected');
                    if (gameState.validMoves.some(m => m.row === r && m.col === c)) {
                        sq.classList.add('valid-move');
                        if (piece) sq.classList.add('has-piece');
                    }
                    sq.onclick = () => handleSquareClick(r, c);
                    el.appendChild(sq);
                }
            }
            renderHistory();
        }

        function handleSquareClick(r, c) {
            if (gameState.isGameOver || (gameState.currentTurn === 'black' && gameState.isAIThinking)) return;
            const piece = gameState.board[r][c];
            if (gameState.selectedPiece && gameState.validMoves.some(m => m.row === r && m.col === c)) {
                makeMove(gameState.selectedPiece, { row: r, col: c });
                return;
            }
            if (piece && piece.color === gameState.currentTurn) {
                gameState.selectedPiece = { row: r, col: c };
                gameState.validMoves = getValidMoves(gameState.board, piece, { row: r, col: c });
                renderBoard();
            } else {
                gameState.selectedPiece = null;
                gameState.validMoves = [];
                renderBoard();
            }
        }

        function updateTurnDisplay() {
            const el = document.getElementById('turnInfo');
            el.innerText = `Lượt: ${gameState.currentTurn === 'white' ? 'Trắng' : 'Đen'}`;
        }

        function renderHistory() {
            const list = document.getElementById('moveList');
            list.innerHTML = '';
            for(let i=0; i<gameState.moveHistory.length; i+=2) {
                const row = document.createElement('div');
                row.className = 'move-row';
                row.innerHTML = `<span>${Math.floor(i/2)+1}.</span><span>${gameState.moveHistory[i]}</span><span>${gameState.moveHistory[i+1] || ''}</span>`;
                list.appendChild(row);
            }
            list.scrollTop = list.scrollHeight;
        }

        function showPromotionModal(color) {
            const modal = document.getElementById('promotionModal');
            const opts = document.getElementById('promotionOptions');
            opts.innerHTML = '';
            ['queen', 'rook', 'bishop', 'knight'].forEach(type => {
                const btn = document.createElement('button');
                btn.className = `promotion-btn piece ${color}`;
                btn.textContent = PIECE_CHARS[type];
                btn.onclick = () => {
                    const pos = gameState.promotionPosition;
                    gameState.board[pos.row][pos.col].type = type;
                    modal.classList.remove('show');
                    gameState.moveHistory[gameState.moveHistory.length-1] += `=${type[0].toUpperCase()}`;
                    endTurn();
                };
                opts.appendChild(btn);
            });
            modal.classList.add('show');
        }

        function resetGame() {
            stopTimer();
            gameState = {
                board: initializeBoard(), currentTurn: 'white', selectedPiece: null, validMoves: [],
                isCheck: false, isGameOver: false, enPassantTarget: null, isAIThinking: false,
                promotionPosition: null, moveHistory: [], timeRemaining: MOVE_TIME_LIMIT, timerInterval: null
            };
            renderBoard();
            updateTurnDisplay();
            startTimer();
        }

        gameState.board = initializeBoard();
        renderBoard();
        startTimer();
    </script>
</body>
</html>
